# 从头构建一个简单的操作系统

## 信息

- 原著名：Writing a Simple Operating System - from Scratch (December 2, 2010)

- 原作者：Nick Blundell

- 译者：kaoru

- 邮箱：<a href='mailto:shiina_kaoru@outlook.com'>shiina_kaoru@outlook.com</a>

- 其他：本文档仅供个人学习参考使用

## 目录

1. [**介绍**](#introduction)

2. [**计算机架构与启动进程**](#computer_architecture_and_the_boot_process)
   
   1. [启动进程](#the_boot_process)
   
   2. [BIOS，启动块（Boot Blocks）以及魔数（Magic Number）](#bios_boot_blocks_and_the_magic_number)
   
   3. CPU 仿真
      
      1. Bochs：一个 x86 CPU 仿真器
      
      2. QEmu
   
   4. 十六进制计数法

3. **启动扇区编程（16 位实模式）**
   
   1. 重新审视启动扇区
   
   2. 16 位实模式
   
   3. Erm, Hello?
      
      1. 中断
      
      2. CPU 寄存器
      
      3. 整合起来
   
   4. Hello, World!
      
      1. 内存、地址和标签
      
      2. 'X' 里程碑
         
         问题 1
      
      3. 定义字符串
      
      4. 使用栈
         
         问题 2
      
      5. 控制结构
         
         问题 3
      
      6. 调用函数
      
      7. 包含文件
      
      8. 整合起来
         
         问题 4
      
      9. 总结
   
   5. Nurse, Fetch me my Steth-o-scope
      
      1. 问题 5（进阶）
   
   6. 读取磁盘
      
      1. 使用段访问拓展内存
      
      2. 磁盘是如何工作的
      
      3. 使用 BIOS 读取磁盘
      
      4. 整合起来

4. **进入 32 位保护模式**
   
   1. 适应没有 BIOS 的生活
   
   2. 理解 GDT（Global Descriptor Table）
   
   3. 在汇编中定义 GDT
   
   4. 模式转变
   
   5. 整合起来

5. **编写、构建并加载你的内核**
   
   1. 理解 C 的编译
      
      1. 生成裸机代码
      
      2. 本地变量
      
      3. 调用函数
      
      4. 指针、地址以及数据
   
   2. 运行我们的内核代码
      
      1. 编写我们的内核
      
      2. 创建一个启动扇区以引导我们的内核（Bootstrap）
      
      3. 找到进入内核的方法
   
   3. 使用 Make 进行自动化构建
      
      1. 组织我们的代码库
   
   4. C 语言
      
      1. 预处理器和指令
      
      2. 函数声明和头文件

6. **开发基本设备驱动程序和文件系统**
   
   1. 硬件 I/O
      
      1. I/O 总线
      
      2. I/O 编程
      
      3. 直接内存访问
   
   2. 显示驱动
      
      1. 理解显示设备
      
      2. 基本显示去驱动的实现
      
      3. 滚动的屏幕
   
   3. 处理中断
   
   4. 键盘驱动
   
   5. 硬盘驱动
   
   6. 文件系统

7. **实现进程**
   
   1. 单进程
   
   2. 多进程

8. **总结**

9. **参考书目**

<span id="introduction"/>

## 1.介绍

在此之前我们都使用过操作系统（例如 Windows XP，Linux 发行版等），也许我们也编写过一些程序在她们当中运行；但操作系统对于我们而言究竟是什么？当我使用电脑时，有多少工作是由硬件完成的，又有多少工作是由软件完成的呢？电脑又是如何完成工作的？

已故的 Doug Shepherd 教授是我在兰开斯特大学的一位活跃的老师，有一次在我埋怨一些烦人的编码问题，他开展研究前，都会从头构建起一个自己的操作系统。所以在今天，我们想知道这些奇妙的机器是如何在底层工作，以及软件如何将硬件捆绑起来，保证他们日复一日稳定地工作。

我们将集中讨论广泛使用 x86 架构 CPU，随着 Doug 的早期步伐一路学习关于：

- 计算机是如何启动的

- 如何在没有操作系统的情况下，编写在裸机上运行的低级代码

- 如何配置 CPU 以使用它提供的拓展功能

- 如何使用高级语言编写引导代码，然后可以在我们的操作系统上运行程序

- 如何创建基本的操作系统服务，例如设备驱动、文件系统、多任务进程

以上是以操作系统的实际功能而言，本指南的目标是分散的，把信息的片段进行汇总成一个自成一体和连贯的文档，这将给你一个积累底层编程经验的机会，如何编写操作系统，并解决各种各样的问题。本指南所采用的方法是独特的，因为采用了特定的语言与工具（例如汇编、C、Make 等），不过这些并不是重点，而是为达成目的的一种手段。我们将学习对完成目标有用的东西。预先善其事，必先利其器。

这项工作的目的并不是替代，而是为了成为优秀的垫脚石，例如 Minix 项目，以及为了一般的操作系统开发。

<span id="computer_architecture_and_the_boot_process"/>

## 2.计算机架构与启动进程

<span id="the_boot_process"/>

## 2.1 启动进程

现在，开始我们的主要工作。

当我们重新启动计算机，它必须在没有任何操作系统的情况下重新初始化一次。在某种程度上，它必须从当前的某种永久存储介质（软盘、硬盘、U盘等）中将操作系统附加到计算机，而且它并不关心操作系统的种类。

我们简短的讨论一下，在操作系统启动前的环境里（pre-OS environment）提供了很少的服务：在这个阶段，即便是一个文件系统都是奢望（例如在磁盘上读写逻辑文件），我们一无所有。幸运的是，我们拥有基础输入输出软件（Basic Input/Output Software - BIOS），一个从最初的芯片加载到内存当中，并在计算机初始化时运行、提供自动检测和基本控制计算机的基本设备，例如屏幕、键盘和硬盘的软件例程集合。

在 BIOS 完成对硬件的基本测试后，尤其是安装上的内存是否正常工作，它必须启动存在与你设备里的操作系统中的一个。在这里我们应该注意到，BIOS 不能简单地从磁盘中加载你的操作系统文件，因为在 BIOS 中还没有文件系统的概念。BIOS 必须从磁盘设备上的物理位置读取特殊扇区的数据（通常大小为 512 字节），例如 2 号柱面，3号磁头，5号扇区（磁盘寻址的细节将在往后的第 X 节中描述）。 

所以，BIOS 的最早的任务就是寻找操作系统所在磁盘的第一个扇区（即 0 号柱面，0 号磁头，0 号扇区），这就是启动扇区。因为我们的磁盘可能不存在有操作系统（比如它们仅为提供额外的存储空间而被连接），那么重要的就是 BIOS 能否确定一个特定的磁盘引导扇区是否存在用于引导操作系统的代码。注意，CPU 不区分代码和数据：它们两者均可被解释为 CPU 指令，代码只是由我们（程序员）精心制作且可用的算法。

BIOS 在这里再次采用了一种简单的方法，将预期引导扇区的最后两个字节设置为魔数 0xAA55。

<span id="bios_boot_blocks_and_the_magic_number"/>

## 2.2 [BIOS，启动块（Boot Blocks）以及魔数（Magic Number）
